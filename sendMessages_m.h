//
// Generated file, do not edit! Created by opp_msgtool 6.0 from sendMessages.msg.
//

#ifndef __SENDMESSAGES_M_H
#define __SENDMESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0600
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class hostMessage;
class obsMessage;
class resourceRequest;
class configurationMessage;
/**
 * Class generated from <tt>sendMessages.msg:7</tt> by opp_msgtool.
 * <pre>
 * packet hostMessage
 * {
 *     unsigned int destinationAdd;	//Direccion de destino
 *     unsigned int sourceAdd;			//Direccion de origen
 *     unsigned int typeOfService;		//Tipo (clase) de servicio
 *     unsigned int payloadLength;		//Longitud de payload del paquete en bytes
 *     unsigned int headerLength;		//Longitud de header del paquete en bytes
 *     double delay;					//Retardo total de transmision del paquete (E2E)
 * 	//double additionalDelay;			//Retardos de procesamiento en los diferentes modulos
 * }
 * </pre>
 */
class hostMessage : public ::omnetpp::cPacket
{
  protected:
    unsigned int destinationAdd = 0;
    unsigned int sourceAdd = 0;
    unsigned int typeOfService = 0;
    unsigned int payloadLength = 0;
    unsigned int headerLength = 0;
    double delay = 0;

  private:
    void copy(const hostMessage& other);

  protected:
    bool operator==(const hostMessage&) = delete;

  public:
    hostMessage(const char *name=nullptr, short kind=0);
    hostMessage(const hostMessage& other);
    virtual ~hostMessage();
    hostMessage& operator=(const hostMessage& other);
    virtual hostMessage *dup() const override {return new hostMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned int getDestinationAdd() const;
    virtual void setDestinationAdd(unsigned int destinationAdd);

    virtual unsigned int getSourceAdd() const;
    virtual void setSourceAdd(unsigned int sourceAdd);

    virtual unsigned int getTypeOfService() const;
    virtual void setTypeOfService(unsigned int typeOfService);

    virtual unsigned int getPayloadLength() const;
    virtual void setPayloadLength(unsigned int payloadLength);

    virtual unsigned int getHeaderLength() const;
    virtual void setHeaderLength(unsigned int headerLength);

    virtual double getDelay() const;
    virtual void setDelay(double delay);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const hostMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, hostMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sendMessages.msg:17</tt> by opp_msgtool.
 * <pre>
 * packet obsMessage
 * {
 *     hostMessage *hostMessageGroup[];	//Vector de mensajes host
 *     unsigned int sourceAdd;				//Igual a la de Host
 *     unsigned int destinationAdd;		//Dirección de destino
 *     unsigned int typeOfService;		//Clase 1, 2 o 3
 *     unsigned int payloadLength;		//Longitud total del payload (payload+header IP) en bytes
 *     unsigned int headerLength;		//Longitud total de la cabecera OBS
 *     unsigned int signalWavelenght;	//Longitud de onda para la transmision de la ráfaga
 *     unsigned int burstID;			//ID para identificar la rafaga en el buffer
 * }
 * </pre>
 */
class obsMessage : public ::omnetpp::cPacket
{
  protected:
    hostMessage * *hostMessageGroup = nullptr;
    size_t hostMessageGroup_arraysize = 0;
    unsigned int sourceAdd = 0;
    unsigned int destinationAdd = 0;
    unsigned int typeOfService = 0;
    unsigned int payloadLength = 0;
    unsigned int headerLength = 0;
    unsigned int signalWavelenght = 0;
    unsigned int burstID = 0;

  private:
    void copy(const obsMessage& other);

  protected:
    bool operator==(const obsMessage&) = delete;

  public:
    obsMessage(const char *name=nullptr, short kind=0);
    obsMessage(const obsMessage& other);
    virtual ~obsMessage();
    obsMessage& operator=(const obsMessage& other);
    virtual obsMessage *dup() const override {return new obsMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual void setHostMessageGroupArraySize(size_t size);
    virtual size_t getHostMessageGroupArraySize() const;
    virtual const hostMessage * getHostMessageGroup(size_t k) const;
    virtual hostMessage * getHostMessageGroupForUpdate(size_t k) { return const_cast<hostMessage *>(const_cast<obsMessage*>(this)->getHostMessageGroup(k));}
    virtual void setHostMessageGroup(size_t k, hostMessage * hostMessageGroup);
    virtual void insertHostMessageGroup(size_t k, hostMessage * hostMessageGroup);
    [[deprecated]] void insertHostMessageGroup(hostMessage * hostMessageGroup) {appendHostMessageGroup(hostMessageGroup);}
    virtual void appendHostMessageGroup(hostMessage * hostMessageGroup);
    virtual void eraseHostMessageGroup(size_t k);

    virtual unsigned int getSourceAdd() const;
    virtual void setSourceAdd(unsigned int sourceAdd);

    virtual unsigned int getDestinationAdd() const;
    virtual void setDestinationAdd(unsigned int destinationAdd);

    virtual unsigned int getTypeOfService() const;
    virtual void setTypeOfService(unsigned int typeOfService);

    virtual unsigned int getPayloadLength() const;
    virtual void setPayloadLength(unsigned int payloadLength);

    virtual unsigned int getHeaderLength() const;
    virtual void setHeaderLength(unsigned int headerLength);

    virtual unsigned int getSignalWavelenght() const;
    virtual void setSignalWavelenght(unsigned int signalWavelenght);

    virtual unsigned int getBurstID() const;
    virtual void setBurstID(unsigned int burstID);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const obsMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, obsMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sendMessages.msg:28</tt> by opp_msgtool.
 * <pre>
 * packet resourceRequest
 * {
 *     unsigned int typeOfMsg;				//Tipo de mensaje enviado
 * 			//Tipo 1: mensaje de solicitud de recursos
 * 			//Tipo 2: ACK de solicitud de recursos, puede enviar la ráfaga
 * 			//Tipo 3: Usados para liberar recursos cuando se envian del nodo al controlador
 *     double generationTime;			//Tiempo en que se genera la resource request (No aplica para la liberacion de recursos)
 *     double resourceDelay;			//Tiempo de retardo generado por la espera de recursos
 *     unsigned int sourceNode;		//El nodo 0 sera el controlador
 *     unsigned int destinationNode;	//Nodo destino de la ráfaga
 *     unsigned int signalWavelenght;	//Longitud de onda asignada por el controlador, solo aplica en el ACK
 *     unsigned int burstID;			//ID para identificar a que rafaga esta asociada la solicitud
 *     unsigned int typeOfService;		//Tipo (clase) de servicio
 * }
 * </pre>
 */
class resourceRequest : public ::omnetpp::cPacket
{
  protected:
    unsigned int typeOfMsg = 0;
    double generationTime = 0;
    double resourceDelay = 0;
    unsigned int sourceNode = 0;
    unsigned int destinationNode = 0;
    unsigned int signalWavelenght = 0;
    unsigned int burstID = 0;
    unsigned int typeOfService = 0;

  private:
    void copy(const resourceRequest& other);

  protected:
    bool operator==(const resourceRequest&) = delete;

  public:
    resourceRequest(const char *name=nullptr, short kind=0);
    resourceRequest(const resourceRequest& other);
    virtual ~resourceRequest();
    resourceRequest& operator=(const resourceRequest& other);
    virtual resourceRequest *dup() const override {return new resourceRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned int getTypeOfMsg() const;
    virtual void setTypeOfMsg(unsigned int typeOfMsg);

    virtual double getGenerationTime() const;
    virtual void setGenerationTime(double generationTime);

    virtual double getResourceDelay() const;
    virtual void setResourceDelay(double resourceDelay);

    virtual unsigned int getSourceNode() const;
    virtual void setSourceNode(unsigned int sourceNode);

    virtual unsigned int getDestinationNode() const;
    virtual void setDestinationNode(unsigned int destinationNode);

    virtual unsigned int getSignalWavelenght() const;
    virtual void setSignalWavelenght(unsigned int signalWavelenght);

    virtual unsigned int getBurstID() const;
    virtual void setBurstID(unsigned int burstID);

    virtual unsigned int getTypeOfService() const;
    virtual void setTypeOfService(unsigned int typeOfService);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const resourceRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, resourceRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>sendMessages.msg:42</tt> by opp_msgtool.
 * <pre>
 * packet configurationMessage
 * {
 *     unsigned int typeOfMsg;		//Tipo de mensaje enviado
 * 			//Tipo 1: solicitud de configuracion
 * 			//Tipo 2: ACK de configuracion
 *     unsigned int destinationNode;	//Nodo destino del mensaje de configuracion/ACK
 *     unsigned int inputTrafficPort;	//Puerto de entrada del tráfico, el 0 sera proveniente del host
 *     unsigned int outputTrafficPort;	//Puerto de salida del tráfico, el 0 sera dirigido hacia el host
 *     unsigned int numberOfNodes;		//Numero de nodos a configurar
 *     unsigned int signalWavelenght;	//Longitud de onda para la cual aplica la configuracion	
 *     unsigned int burstID;			//ID del proceso de configuracion (usado para diferenciar entre las diferentes ordenes de config)
 * 										//Para este caso es la misma que el signalWavelenght, pero varia cuando se usan FSs
 *     double delayAI;					//Delay introducido por el procesamiento del AI
 *     double requestGenerationDelay;	//Delay introducido por la solicitud de recursos
 *     double configurationDelay;		//Retardo introducido por la configuración del camino óptico
 * }
 * </pre>
 */
class configurationMessage : public ::omnetpp::cPacket
{
  protected:
    unsigned int typeOfMsg = 0;
    unsigned int destinationNode = 0;
    unsigned int inputTrafficPort = 0;
    unsigned int outputTrafficPort = 0;
    unsigned int numberOfNodes = 0;
    unsigned int signalWavelenght = 0;
    unsigned int burstID = 0;
    double delayAI = 0;
    double requestGenerationDelay = 0;
    double configurationDelay = 0;

  private:
    void copy(const configurationMessage& other);

  protected:
    bool operator==(const configurationMessage&) = delete;

  public:
    configurationMessage(const char *name=nullptr, short kind=0);
    configurationMessage(const configurationMessage& other);
    virtual ~configurationMessage();
    configurationMessage& operator=(const configurationMessage& other);
    virtual configurationMessage *dup() const override {return new configurationMessage(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual unsigned int getTypeOfMsg() const;
    virtual void setTypeOfMsg(unsigned int typeOfMsg);

    virtual unsigned int getDestinationNode() const;
    virtual void setDestinationNode(unsigned int destinationNode);

    virtual unsigned int getInputTrafficPort() const;
    virtual void setInputTrafficPort(unsigned int inputTrafficPort);

    virtual unsigned int getOutputTrafficPort() const;
    virtual void setOutputTrafficPort(unsigned int outputTrafficPort);

    virtual unsigned int getNumberOfNodes() const;
    virtual void setNumberOfNodes(unsigned int numberOfNodes);

    virtual unsigned int getSignalWavelenght() const;
    virtual void setSignalWavelenght(unsigned int signalWavelenght);

    virtual unsigned int getBurstID() const;
    virtual void setBurstID(unsigned int burstID);

    virtual double getDelayAI() const;
    virtual void setDelayAI(double delayAI);

    virtual double getRequestGenerationDelay() const;
    virtual void setRequestGenerationDelay(double requestGenerationDelay);

    virtual double getConfigurationDelay() const;
    virtual void setConfigurationDelay(double configurationDelay);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const configurationMessage& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, configurationMessage& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline hostMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<hostMessage*>(ptr.get<cObject>()); }
template<> inline obsMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<obsMessage*>(ptr.get<cObject>()); }
template<> inline resourceRequest *fromAnyPtr(any_ptr ptr) { return check_and_cast<resourceRequest*>(ptr.get<cObject>()); }
template<> inline configurationMessage *fromAnyPtr(any_ptr ptr) { return check_and_cast<configurationMessage*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __SENDMESSAGES_M_H

